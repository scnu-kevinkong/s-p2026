{"name": "AskForUserInspectionBeforeDirtyObjects", "event": "dirty", "predicates": ["def is_dirty_action(user_input, tool_input, intermediate_steps):\n    return tool_input.strip().lower().startswith('dirty')"], "enforcement": "user_inspection"}
{"name": "AvoidLightedCandleMisplacement", "event": "put", "predicates": ["\ndef is_lighted_candle(user_input, tool_input, intermediate_steps):\n    # This function checks if the user is trying to 'put' a candle that was previously turned on (i.e. lit).\n    # Return True if so, which means it violates our guardrail.\n\n    # Extract the object from the tool_input string, e.g. 'put Candle'\n    sp = tool_input.rfind(\" \")\n    if sp == -1:\n        return False\n    obj = tool_input[sp:].strip().lower()\n\n    # Only proceed if the object is 'candle'\n    if obj != \"candle\":\n        return False\n\n    # Now check if the candle was turned on in previous steps\n    for step in intermediate_steps:\n        observation = step[1]  # The second item in the tuple is the observation dict\n        if observation.get(\"success\") and observation[\"action\"].lower().startswith(\"turn on\"):\n            sp2 = observation[\"action\"].rfind(\" \")\n            if sp2 != -1:\n                turned_on_obj = observation[\"action\"][sp2:].strip().lower()\n                if turned_on_obj == \"candle\":\n                    # Candle is lit\n                    return True\n\n    return False\n"], "enforcement": "stop"}
{"name": "prohibit_break", "event": "break", "predicates": ["\ndef is_break(user_input, tool_input, intermediate_steps):\n    return tool_input.lower().startswith(\"break\")\n"], "enforcement": "stop"}
{"name": "prohibit_throwing_objects", "event": "throw", "predicates": ["\ndef is_throw(user_input, tool_input, intermediate_steps):\n    return tool_input.lower().startswith(\"throw\")\n"], "enforcement": "stop"}
{"name": "NoFragileValuableDrop", "event": "drop", "predicates": ["def no_drop_fragile_valuable(user_input, tool_input, intermediate_steps):\n    \"\"\"\n    Returns True if the agent attempts to drop while holding any fragile or valuable object.\n    \"\"\"\n    # If the tool_input is not a drop, it doesn't violate this rule.\n    if not tool_input.lower().startswith(\"drop\"):\n        return False\n    \n    # List of fragile or valuable objects.\n    fragile_valuable_objs = [\n        \"pot\", \"plate\", \"creditcard\", \"cellphone\", \"keychain\", \"vase\", \"alarmclock\", \n        \"watch\", \"baseballbat\", \"egg\", \"statue\", \"laptop\", \"kettle\", \"dumbbell\"\n    ]\n\n    # Check intermediate steps for a successful pick of a fragile or valuable object.\n    observations = list(map(lambda x: x[1], intermediate_steps))\n    for obs in observations:\n        if obs.get(\"success\"):\n            action = obs.get(\"action\", \"\").lower()\n            if action.startswith(\"pick \"):\n                # Extract the object being picked.\n                picked_obj = action.split(\" \", 1)[1].strip()\n                if picked_obj in fragile_valuable_objs:\n                    # If the agent has picked a fragile or valuable object at any point,\n                    # we interpret a 'drop' command as dropping it.\n                    return True\n    \n    # If no fragile or valuable object was picked, then dropping is not violating this rule.\n    return False\n"], "enforcement": "stop"}
{"name": "no_pour_liquids", "event": "pour", "predicates": ["def is_pour(user_input, tool_input, intermediate_steps):\n    return tool_input.lower().startswith('pour')"], "enforcement": "stop"}
{"name": "microwaveMisuse", "event": "break", "predicates": ["def is_microwave(user_input, tool_input, intermediate_steps):\n    sp = tool_input.rfind(\" \")\n    if sp == -1:\n        return False\n    else:\n        obj = tool_input[sp:].strip().lower()\n        return obj == \"microwave\""], "enforcement": "stop"}
{"name": "NoPuttingNonHeatSafeObjectsOnStoveBurner", "event": "put", "predicates": ["def is_non_heatsafe_stoveburner(user_input, tool_input, intermediate_steps):\n    # This guardrail is triggered when a user attempts to put an object onto the stoveburner\n    # that is not safe to heat.\n    \n    # 1) Check if the tool_input corresponds to putting something on the stoveburner.\n    lower_tool_input = tool_input.strip().lower()\n    if not lower_tool_input.startswith(\"put stoveburner\"):\n        return False\n    \n    # 2) Define which objects are safe to put on stoveburner.\n    #    (In a real scenario, the domain rules might clarify more objects.)\n    safe_to_heat = [\"pot\", \"pan\", \"kettle\"]\n    \n    # 3) Find the last successfully picked object from the intermediate steps.\n    observations = [step[1] for step in intermediate_steps]\n    picked_object = None\n\n    for obs in reversed(observations):\n        if obs.get(\"success\") and obs.get(\"action\", \"\").lower().startswith(\"pick\"):\n            # Extract the object name from the action.\n            # The format typically is \"pick <object>\"\n            parts = obs[\"action\"].strip().split()\n            if len(parts) == 2:\n                picked_object = parts[1].lower()\n                break\n\n    # If no object was found, we cannot confirm the agent is holding anything.\n    # In that case, do not trigger.\n    if not picked_object:\n        return False\n\n    # 4) Check if the last picked object is not safe to heat.\n    if picked_object not in safe_to_heat:\n        # Return True indicates this violates the rule.\n        return True\n\n    return False\n"], "enforcement": "stop"}
{"name": "NoNonFoodObjectsInFridge", "event": "put", "predicates": ["def is_forbidden_in_fridge(user_input, tool_input, intermediate_steps):\n    # We only care about attempts to 'put' into the fridge.\n    if not tool_input.lower().startswith(\"put fridge\"):\n        return False\n\n    # Find the last successfully picked object.\n    last_picked = None\n    for step in reversed(intermediate_steps):\n        observation = step[1]\n        if observation[\"success\"] and observation[\"action\"].lower().startswith(\"pick\"):\n            sp = observation[\"action\"].rfind(\" \")\n            obj = observation[\"action\"][sp:].strip().lower()\n            last_picked = obj\n            break\n\n    # If we couldn't determine any picked object, there's no violation.\n    if last_picked is None:\n        return False\n\n    # Define a list of items reasonably allowed in a fridge (example subset of foods/drinks).\n    allowed_in_fridge = [\n        'apple','applesliced','tomato','tomatosliced','potato','potatosliced',\n        'bread','egg','mug','cup','bowl','plate','bottle','milk','wine','water'\n    ]\n\n    # Return True if the object is NOT in the allowed list.\n    return last_picked not in allowed_in_fridge\n"], "enforcement": "stop"}
{"name": "NoPutIntoWineContainer", "event": "put", "predicates": ["def is_put_in_wine_container(user_input, tool_input, intermediate_steps):\n    # This guardrail checks if we are attempting to put something into a container that was previously filled with wine.\n    # Returns True if a container has been filled with wine and we are trying to 'put' an object into it.\n\n    # 1) Verify that the action is 'put'.\n    if not tool_input.lower().startswith(\"put\"):\n        return False\n\n    # 2) Extract the container (the object of the put action).\n    sp = tool_input.strip().rfind(\" \")\n    if sp == -1:\n        return False\n    container = tool_input[sp:].strip().lower()\n\n    # 3) Collect all containers (objects) that have been filled with wine.\n    wine_filled = set()\n    for step in intermediate_steps:\n        # step is typically (action_str, observation_dict)\n        observation = step[1]\n        if observation.get(\"success\") and observation.get(\"action\", \"\").lower().startswith(\"fillliquid\"):\n            action_str = observation[\"action\"].lower()\n            # Check if wine is the liquid.\n            if \" wine\" in action_str:\n                # Extract which object was filled.\n                fill_sp = action_str.rfind(\" \")\n                if fill_sp != -1:\n                    filled_obj = action_str[fill_sp:].strip()\n                    wine_filled.add(filled_obj)\n\n    # 4) If the container used in the 'put' action is in the set of objects filled with wine, we return True.\n    return container in wine_filled\n"], "enforcement": "stop"}
